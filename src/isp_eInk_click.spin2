'' =================================================================================================
''
''   File....... isp_eInk_click.spin2
''   Purpose.... Interface to the Mikroe eInk Click module w/display
''   Authors.... Stephen M Moraco
''               -- Copyright(c) 2022 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Jun 2022
''   Updated.... 08 Jun 2022
''
'' =================================================================================================

CON { Public Interface Constants }

    '  ID where the P2 Eval Click Adapter for eInk Click is plugged in (Enum)
    ' (Names of supported PinGroups)
    #0[16], PINS_P0_P15, PINS_P16_P31, PINS_P32_P47
    ' return value when user makes bad choice
    INVALID_PIN_BASE = -1

    #40, DS_eink154, DS_eink200, DS_eink213, DS_eink290

    ' forward the font constants so user can select an internal font
    FONT_Tahoma_6 = eInkFonts.FONT_Tahoma_6
    FONT_Tahoma_7 = eInkFonts.FONT_Tahoma_7
    FONT_Tahoma_8 = eInkFonts.FONT_Tahoma_8
    FONT_Tahoma_10 = eInkFonts.FONT_Tahoma_10
    FONT_Tahoma_14 = eInkFonts.FONT_Tahoma_14
    FONT_Tahoma_16 = eInkFonts.FONT_Tahoma_16
    FONT_Tahoma_18 = eInkFonts.FONT_Tahoma_18
    FONT_Exo_2_Condensed10x16 = eInkFonts.FONT_Exo_2_Condensed10x16
    FONT_Exo_2_Condensed15x23 = eInkFonts.FONT_Exo_2_Condensed15x23
    FONT_Exo_2_Condensed21x32 = eInkFonts.FONT_Exo_2_Condensed21x32
    FONT_Roboto_Mono11x23 = eInkFonts.FONT_Roboto_Mono11x23

    FONT_UNKNOWN = eInkFonts.FONT_UNKNOWN


OBJ { Objects / constants included by this object }

    eInkFonts   : "isp_eInk_fonts"              ' eInt ported font set
    spi         : "jm_ez_spi"                   '   smart pin mode 0 spi coms


CON { Click Module offsets }
 {

    P2 Eval Click Adapter IO Assignments
    * - used by eInk Click module w/display(3.3v only)

               ┌─────────────────────────────┐
    Base + 06  │() AN                 D/C(*) │  Base + 05
               │                             │
    Base + 07  │(*) RST               BSY(*) │  Base + 04
               │                             │
    Base + 08  │(*) CS              <-- RX() │  Base + 03(marked TX on Click modules)
               │                             │
    Base + 09  │(*) SCK  <--        --> TX() │  Base + 02(marked RX on Click modules)
               │                             │
    Base + 10  │(*) MISO -->       --> SCL() │  Base + 01
               │                             │
    Base + 11  │(*) MOSI <--       <-> SDA() │  Base + 00
               │                             │
               │(*) 3v3                5v0() │
               │                             │
               │(*) GND               GND(*) │
               └─────────────────────────────/
}

    ' specs for Click EINK board
   CLICK_OFST_MOSI = 11     ' Mikroe pin 6  - SPI Data - Out
   CLICK_OFST_MISO = 10     ' N/C  Mikroe pin 5
   CLICK_OFST_SCK = 9       ' Mikroe pin 4  - SPI Clock - Out
   CLICK_OFST_CS = 8        ' Mikroe pin 3  - SPI Chip Select - Out
   CLICK_OFST_RST = 7       ' Mikroe pin 2  - Reset - Out
   'CLICK_OFST_AN = 6       ' N/C  Mikroe pin 1

   CLICK_OFST_DC = 5       ' Mikroe pin 16 - D/C - Out Data Config(normally CLICK_OFST_PWM)
   CLICK_OFST_BSY = 4       ' Mikroe pin 15 - Busy - In(normally CLICK_OFST_INT)
   'CLICK_OFST_RX = 3       ' N/C  Mikroe pin 14
   'CLICK_OFST_TX = 2       ' N/C  Mikroe pin 13
   'CLICK_OFST_SCL = 1      ' N/C  Mikroe pin 12
   'CLICK_OFST_SDA = 0      ' N/C  Mikroe pin 11

CON { eInk Constants }

' error_code Error Code
    EINK_OK                     = $00
    EINK_INIT_ERROR             = $FF

' ---------------------------------------
' display_resolution Display resolution
'
' NOTE: uncomment one oof the following for your display size
'
{
    DISPLAY_WIDTH = 200
    DISPLAY_HEIGHT = 200
    DISPLAY_RESOLUTIONS = 5000

    DISPLAY_WIDTH               = DISPLAY_WIDTH
    DISPLAY_HEIGHT              = DISPLAY_HEIGHT
    FRAME_SIZE_IN_BYTES         = DISPLAY_RESOLUTIONS

    DISPLAY_TYPE                = DS_eink154
'}
{
    DISPLAY_WIDTH = 72
    DISPLAY_HEIGHT = 172
    DISPLAY_RESOLUTION = 3096

    DISPLAY_WIDTH               = DISPLAY_WIDTH
    DISPLAY_HEIGHT              = DISPLAY_HEIGHT
    FRAME_SIZE_IN_BYTES         = DISPLAY_RESOLUTION

    DISPLAY_TYPE                = DS_eink200
'}
'{
    EINK213_DISPLAY_WIDTH = 128
    EINK213_DISPLAY_HEIGHT = 250
    EINK213_DISPLAY_RESOLUTIONS = 4000

    DISPLAY_WIDTH               = EINK213_DISPLAY_WIDTH
    DISPLAY_HEIGHT              = EINK213_DISPLAY_HEIGHT
    FRAME_SIZE_IN_BYTES         = EINK213_DISPLAY_RESOLUTIONS

    DISPLAY_TYPE                = DS_eink213
'}
{
    EINK290_DISPLAY_WIDTH = 128
    EINK290_DISPLAY_HEIGHT = 296
    EINK290_DISPLAY_RESOLUTIONS = 4736

    DISPLAY_WIDTH               = EINK290_DISPLAY_WIDTH
    DISPLAY_HEIGHT              = EINK290_DISPLAY_HEIGHT
    FRAME_SIZE_IN_BYTES         = EINK290_DISPLAY_RESOLUTIONS

    DISPLAY_TYPE                = DS_eink290
'}

' fillScreen_color Fill screen color
    ' $FF=white, $00=black, $55=gray 1, $AA=gray 2
    EINK_COLOR_WHITE          = $FF
    EINK_COLOR_BLACK          = $00
    EINK_COLOR_LIGHT_GREY     = $AA
    EINK_COLOR_DARK_GREY      = $55

' character orientation on screen
    FO_HORIZONTAL               = $00
    FO_VERTICAL                 = $01
    FO_VERTICAL_COLUMN          = $02

' display_commands Display Commands
    CMD_DRIVER_OUTPUT_CTRL          = $01
    CMD_BOOSTER_SOFT_START_CTRL     = $0C
    CMD_GATE_SCAN_START_POSN        = $0F
    CMD_DEEP_SLEEP_MODE             = $10
    CMD_DATA_ENTRY_MODE_SETTING     = $11
    CMD_SW_RESET                    = $12
    CMD_TEMPERATURE_SENSOR_CTRL     = $1A
    CMD_MASTER_ACTIVATION           = $20
    CMD_DISPLAY_UPDATE_CTRL_1       = $21
    CMD_DISPLAY_UPDATE_CTRL_2       = $22
    CMD_WRITE_RAM                   = $24
    CMD_WRITE_VCOM_REGISTER         = $2C
    CMD_WRITE_LUT_REGISTER          = $32
    CMD_SET_DUMMY_LINE_PERIOD       = $3A
    CMD_SET_GATE_TIME               = $3B
    CMD_BORDER_WAVEFORM_CTRL        = $3C
    CMD_SET_RAM_X_ADDR_SRTEND_POS   = $44
    CMD_SET_RAM_Y_ADDR_SRTEND_POS   = $45
    CMD_SET_RAM_X_ADDR_CTR          = $4E
    CMD_SET_RAM_Y_ADDR_CTR          = $4F
    CMD_BOOSTER_FEEDBACK_SELECTION  = $F0
    CMD_TERMINATE_FRAME_READ_WRITE  = $FF

    ' SPI Communication Freq w/EINK Board
    EINK_SPI_CLK_MHZ = 20_000

PUB null()

'' This is not a top-level object


PUB start(eClickBasePin) : ok | legalBase
'' Specify the eval board connect location for the EINK click and start SPI
' REF https://www.mikroe.com/eink-click
   ' ensure we only use legal values
    legalBase := eClickBasePin
    case eClickBasePin
        PINS_P0_P15 :
        PINS_P16_P31 :
        PINS_P32_P47 :
        OTHER :
            legalBase := INVALID_PIN_BASE

    ' if legal base-pin then start cog
    ok := false
    if legalBase <> INVALID_PIN_BASE
        pinbase := legalBase                    ' record base pin number
        ' configure inputs
        pinfloat(pinbase + CLICK_OFST_BSY)
        'pinfloat(pinbase + CLICK_OFST_MOSI)
        ' assert reset while starting up
        pinlow(pinbase + CLICK_OFST_RST)
        ' Deselect the click SPI device
        pinhigh(pinbase + CLICK_OFST_CS)
        ' start the smart pins                            ' deselect EINK Click
        ok := spi.start(pinbase + CLICK_OFST_MISO, pinbase + CLICK_OFST_MOSI, pinbase + CLICK_OFST_SCK, EINK_SPI_CLK_MHZ)                     ' spi to EINK @ 3MHz(can run at 20MHz)

        ' reset device
        resetDevice()

        '  Click initialization based on display size
        startConfig(DISPLAY_TYPE)

PUB stop()
'' Stop the EINK Click SPI Object
    spi.stop()


CON ' ---- PUBLIC interface Methods ----


PUB enableDevice()
'' Enable the EINK Device(pull it out of reset)
    pinhigh(pinbase + CLICK_OFST_RST)                       ' de-assert reset

PUB resetDevice()
'' Reset the EINK device
    pinhigh(pinbase + CLICK_OFST_CS)    ' CS idle=1
    pinlow(pinbase + CLICK_OFST_SCK)    ' SCLK idle=0

    pinhigh(pinbase + CLICK_OFST_RST)   ' toggle reset
    waitms(1)
    pinlow(pinbase + CLICK_OFST_RST)
    waitms(2)
    pinhigh(pinbase + CLICK_OFST_RST)
    waitms(3)

{PRI reset()
' from library source
    pinlow(pinbase + CLICK_OFST_RST)
    waitms(200)
    pinhigh(pinbase + CLICK_OFST_RST)
    waitms(200)
}

PUB enterSleepMode()
'' Tell device to sleep
    writeCmd(CMD_DEEP_SLEEP_MODE)
    waitForDeviceIdle()

PUB setFont(orientation, color, eFont) | pFont
'' Set font configuration

    pFont := eInkFonts.fontAddress(eFont)
    if pFont == FONT_UNKNOWN
        return

    fontAddr        := pFont
    first_char      := BYTE [pFont][ 2 ] + (BYTE [pFont][ 3 ] << 8)
    last_char       := BYTE [pFont][ 4 ] + (BYTE [pFont][ 5 ] << 8)
    fontHeight      := BYTE [pFont][ 6 ]
    fontColor       := color
    fontOrientation := orientation
    debug("ft: fontAddr ", uhex_Long_(first_char))
    debug("ft: first_char ", udec_(first_char), ", ", uhex_byte_(first_char))
    debug("ft: last_char ", udec_(last_char), ", ", uhex_byte_(last_char))
    debug("ft: fontHeight ", udec_(fontHeight))
    debug("ft: fontColor ", uhex_(fontColor))


PUB fillScreen(color) | xCtr, yCtr, fillColor, byteCtr
'' Fill display with {color}
    ' override color if it is not one of the supported four!
    fillColor := validColor(color)

    setMemoryArea(0, 0, DISPLAY_WIDTH - 1, DISPLAY_HEIGHT - 1)

    if DISPLAY_TYPE <> DS_eink213
        ' new? non-2.13 means of doing this...
        setMemoryPointer(0, 0)
        writeCmd(CMD_WRITE_RAM)
        repeat byteCtr from 0 to FRAME_SIZE_IN_BYTES - 1
            writeData(fillColor)

    else
        ' old? 2.13 means of doing this...
        ' for each display line...
        repeat yCtr from 0 to DISPLAY_HEIGHT - 1
            setMemoryPointer(0, yCtr)
            ' write contents for this line
            writeCmd(CMD_WRITE_RAM)
            repeat xCtr from 0 to 16 - 1
                writeData(fillColor)

    displayDelay()
    updateDisplay(DISPLAY_TYPE)

PUB setBackground(color)
'' Fill display with {color}
    bkgndColor := validColor(color)
    ' preset background color
    bytefill(@deviceFrame, bkgndColor, FRAME_SIZE_IN_BYTES)


PUB showImage(pImageBffr) | xCtr, yCtr, imgIdx
'' Write image bitmap to display
    setMemoryArea(0, 0, DISPLAY_WIDTH - 1, DISPLAY_HEIGHT - 1)

    if DISPLAY_TYPE <> DS_eink213
        ' new? non-2.13 means of doing this...
        setMemoryPointer(0, 0)
        writeCmd(CMD_WRITE_RAM)
        repeat imgIdx from 0 to FRAME_SIZE_IN_BYTES - 1
            writeData(BYTE [@pImageBffr][ imgIdx ])

    else
        ' old? 2.13 means of doing this...
        ' for each display line...
        repeat yCtr from 0 to DISPLAY_HEIGHT - 1
            setMemoryPointer(0, yCtr)
            ' write contents for this line
            writeCmd(CMD_WRITE_RAM)
            repeat xCtr from 0 to 16 - 1
                imgIdx := xCtr +(yCtr * 16)
                writeData(BYTE [pImageBffr][imgIdx])

    ' flush content to display
    updateDisplay(DISPLAY_TYPE)


PUB showTextAtXY(X, Y, pText) | xCtr, yCtr, strIdx, nChar, byteCtr
'' Place zstr on display at device row, column
    if (X >= DISPLAY_WIDTH) || (Y >= DISPLAY_HEIGHT)
        return

    nChar := strsize(pText)

    deviceX := X
    deviceY := Y

    repeat strIdx from 0 to nChar - 1
        char_wr(BYTE [pText][strIdx])

    setMemoryArea(0, 0, DISPLAY_WIDTH - 1, DISPLAY_HEIGHT - 1)

    if DISPLAY_TYPE <> DS_eink213
        ' new? non-2.13 means of doing this...
        setMemoryPointer(0, 0)
        writeCmd(CMD_WRITE_RAM)
        repeat byteCtr from 0 to FRAME_SIZE_IN_BYTES - 1
            writeData(BYTE [@deviceFrame][ byteCtr ])

    else
        ' old? 2.13 means of doing this...
        ' for each display line...
        repeat yCtr from 0 to DISPLAY_HEIGHT - 1
            setMemoryPointer(0, yCtr)
            ' write contents for this line
            writeCmd(CMD_WRITE_RAM)
            repeat xCtr from 0 to 16 - 1          ' wtf did this 16 come from? (why not width related?)
                byteCtr := xCtr + (yCtr * 16)
                writeData(BYTE [@deviceFrame][ byteCtr ])

    ' flush content to display
    displayDelay()
    updateDisplay(DISPLAY_TYPE)

PUB borderAtXY(X,Y, color, thickness, width, height) | lineCt, topRow, botRow, ltCol, rtCol
    topRow := Y
    botRow := Y + height - 1
    ltCol := X
    rtCol := X + width - 1
    ' now draw lines (1 px thickness)
    lineAtXY(ltCol, topRow, rtCol, topRow, color) ' top horiz
    lineAtXY(ltCol, botRow, rtCol, botRow, color) ' bottom horiz
    lineAtXY(ltCol, topRow, ltCol, botRow, color) ' left vert
    lineAtXY(rtCol, topRow, rtCol, botRow, color) ' right vert
    if thickness > 1
        repeat lineCt from 0 to thickness - 2
            topRow++
            botRow--
            ltCol++
            rtCol--
            if botRow >= topRow or ltCol >= rtCol
                quit
            lineAtXY(ltCol, topRow, rtCol, topRow, color) ' top horiz
            lineAtXY(ltCol, botRow, rtCol, botRow, color) ' bottom horiz
            lineAtXY(ltCol, topRow, ltCol, botRow, color) ' left vert
            lineAtXY(rtCol, topRow, rtCol, botRow, color) ' right vert


PUB lineAtXY(fmX, fmY, toX, toY, color) | vFmX, vFmY, vToX, vToY, xOffset, yOffset, lineColor
' draw line into device buffer
    vFmX := 0 #> fmX <# DISPLAY_WIDTH
    vFmY := 0 #> fmY <# DISPLAY_HEIGHT
    vToX := 0 #> toX <# DISPLAY_WIDTH
    vToY := 0 #> toY <# DISPLAY_HEIGHT

    lineColor := validColor(color)
    ' Draw Line - start co-ords, end co-ords, color
    'plot incrementing x axis
    repeat xOffset from 0 to vToX - vFmX
        yOffset := (vToY - vFmY) * xOffset / (vToX - vFmX)
        frame_px(vFmX + xOffset, vFmY + yOffset, lineColor)
    'plot incrementing y axis
    repeat yOffset from 0 to vToY-vFmY
        xOffset := (vToX - vFmX) * yOffset / (vToY - vFmY)
        frame_px(vFmX + xOffset, vFmY + yOffset, lineColor)


CON ' ---- PRIVATE Utility Methods ----

PRI startConfig(eDisplaySize)
' configure our display
    case eDisplaySize
        DS_eink154:
            writeCmd(CMD_DRIVER_OUTPUT_CTRL)
            writeData(((DISPLAY_HEIGHT - 1) & $FF))
            writeData((((DISPLAY_HEIGHT - 1) >> 8) & $FF))
            writeData($00)
            writeCmd(CMD_BOOSTER_SOFT_START_CTRL)
            writeData($D7)
            writeData($D6)
            writeData($9D)
            writeCmd(CMD_WRITE_VCOM_REGISTER)
            writeData($A8)
            writeCmd(CMD_SET_DUMMY_LINE_PERIOD)
            writeData($1A)
            writeCmd(CMD_SET_GATE_TIME)
            writeData($08)
            writeCmd(CMD_DATA_ENTRY_MODE_SETTING)
            writeData($03)

            displayDelay()
            setDeviceLut(@EINK154_LUT_TABLE, 30)
        DS_eink200:

            writeCmd(CMD_DEEP_SLEEP_MODE)
            writeData ($00)
            writeCmd(CMD_DATA_ENTRY_MODE_SETTING)
            writeData ($01)

            writeCmd(CMD_SET_RAM_X_ADDR_SRTEND_POS)
            writeData ($00)
            writeData ($11)
            writeCmd(CMD_SET_RAM_Y_ADDR_SRTEND_POS)
            writeData ($00)
            writeData ($AB)

            writeCmd(CMD_SET_RAM_X_ADDR_CTR)
            writeData ($00)
            writeCmd(CMD_SET_RAM_Y_ADDR_CTR)
            writeData ($00)

            writeCmd(CMD_BOOSTER_FEEDBACK_SELECTION)
            writeData($1F)
            writeCmd(CMD_DISPLAY_UPDATE_CTRL_1)
            writeData($03)
            writeCmd(CMD_WRITE_VCOM_REGISTER)
            writeData($A0)
            writeCmd(CMD_BORDER_WAVEFORM_CTRL)
            writeData($63)
            writeCmd(CMD_DISPLAY_UPDATE_CTRL_2)
            writeData($C4)

            displayDelay()
            setDeviceLut(@EINK200_LUT_TABLE, 90)

        DS_eink213:
            writeCmd(CMD_DRIVER_OUTPUT_CTRL)
            writeData((DISPLAY_HEIGHT - 1) & $FF)
            writeData(((DISPLAY_HEIGHT - 1) >> 8) & $FF)

            writeCmd(CMD_SET_DUMMY_LINE_PERIOD)
            writeData($06)
            writeCmd(CMD_SET_GATE_TIME)
            writeData($0B)

            writeCmd(CMD_DATA_ENTRY_MODE_SETTING)
            writeData($01)

            writeCmd(CMD_SET_RAM_X_ADDR_SRTEND_POS)
            writeData($00)
            writeData($0F)
            writeCmd(CMD_SET_RAM_Y_ADDR_SRTEND_POS)
            writeData($F9)
            writeData($00)

            writeCmd(CMD_WRITE_VCOM_REGISTER)
            writeData($4B)

            writeCmd(CMD_BORDER_WAVEFORM_CTRL)
            writeData($33)

            displayDelay()
            setDeviceLut(@EINK213_BIG_LUT_TABLE, 70)

        DS_eink290:
            writeCmd(CMD_DRIVER_OUTPUT_CTRL)
            writeData(((DISPLAY_HEIGHT - 1) & $FF))
            writeData((((DISPLAY_HEIGHT - 1) >> 8) & $FF))
            writeData($00)

            ' New eink display sttings
            writeCmd(CMD_SET_DUMMY_LINE_PERIOD)
            writeData($1A)
            writeCmd(CMD_SET_GATE_TIME)
            writeData($08)

            writeCmd(CMD_DATA_ENTRY_MODE_SETTING)
            writeData($01)
            writeCmd(CMD_SET_RAM_X_ADDR_SRTEND_POS)
            writeData($00)
            writeData($0f)
            writeCmd(CMD_SET_RAM_Y_ADDR_SRTEND_POS)
            writeData($27)
            writeData($01)
            writeData($00)
            writeData($00)

            writeCmd(CMD_WRITE_VCOM_REGISTER)
            writeData($6E)
            writeCmd(CMD_BORDER_WAVEFORM_CTRL)
            writeData($33)
            writeCmd(CMD_DATA_ENTRY_MODE_SETTING)
            writeData($03)

            displayDelay()
            setDeviceLut(@EINK290_LUT_TABLE, 70)
        other:
            debug("sc() ERROR unknown display size")

    waitms(1000)    ' let device settle


PRI setDeviceLut(pLut, nBytes) | nIdx
' write the device LUT data
    writeCmd(CMD_WRITE_LUT_REGISTER)
    repeat nIdx from 0 to nBytes - 1
        writeData(BYTE [pLut][nIdx])


PRI displayDelay()
' wait for settle time
    waitms(2)


PRI setMemoryPointer(x, y)
' set pointer to RAM
    writeCmd(CMD_SET_RAM_X_ADDR_CTR)
    writeData(((x >> 3) & $FF))
    writeCmd(CMD_SET_RAM_Y_ADDR_CTR)
    writeData((y & $FF))
    writeData(((y >> 8) & $FF))


PRI setMemoryArea(xStart, yStart, xEnd, yEnd)
' set region of RAM
    writeCmd(CMD_SET_RAM_X_ADDR_SRTEND_POS)
    writeData((xStart >> 3) & $FF)
    writeData((xEnd >> 3) & $FF)
    writeCmd(CMD_SET_RAM_Y_ADDR_SRTEND_POS)
    writeData(yStart & $FF)
    writeData((yStart >> 8) & $FF)
    writeData(yEnd & $FF)
    writeData((yEnd >> 8) & $FF)


PRI updateDisplay(eDisplaySize)
'' Tell display to show updates
    waitms(100)

    case eDisplaySize
        DS_eink154:
            writeCmd(CMD_DISPLAY_UPDATE_CTRL_2)
            writeData($C4)
            writeCmd(CMD_MASTER_ACTIVATION)
            writeCmd(CMD_TERMINATE_FRAME_READ_WRITE)
        DS_eink200:
            writeCmd(CMD_DISPLAY_UPDATE_CTRL_2)
            writeData($02)
            writeCmd(CMD_MASTER_ACTIVATION)
        DS_eink213:
            writeCmd(CMD_DISPLAY_UPDATE_CTRL_2)
            writeData($C7)
            writeCmd(CMD_MASTER_ACTIVATION)
            writeCmd(CMD_TERMINATE_FRAME_READ_WRITE)
        DS_eink290:
            writeCmd(CMD_DISPLAY_UPDATE_CTRL_2)
            writeData($C7)
            writeCmd(CMD_MASTER_ACTIVATION)
            writeCmd(CMD_TERMINATE_FRAME_READ_WRITE)
        other:
            debug("ud() ERROR unknown display size")

    waitForDeviceIdle()


PRI waitForDeviceIdle() | state
    ' wait until BUSY is de-asserted
    repeat
        state := pinread(pinbase + CLICK_OFST_BSY)
        if state
            waitms(100)
    until state == 0

PRI validColor(rawColor) : retColor
    retColor := rawColor

    ' override color if it is not one of the supported four!
    case rawColor
        EINK_COLOR_WHITE:
        EINK_COLOR_BLACK:
        EINK_COLOR_LIGHT_GREY:
        EINK_COLOR_DARK_GREY:
        other:
            retColor := EINK_COLOR_WHITE    ' default


DAT { object class data }

    pinbase         LONG    0

    fontAddr        LONG    0
    first_char      LONG    0
    last_char       LONG    0
    fontHeight      LONG    0
    fontColor       LONG    0
    bkgndColor      LONG    0
    fontOrientation LONG    0
    deviceX         LONG    0
    deviceY         LONG    0
    deviceFrame     BYTE    0[FRAME_SIZE_IN_BYTES]

     EINK154_LUT_TABLE      BYTE    $02, $02, $01, $11, $12, $12, $22, $22      ' 30 bytes long!
                            BYTE    $66, $69, $69, $59, $58, $99, $99, $88
                            BYTE    $00, $00, $00, $00, $F8, $B4, $13, $51
                            BYTE    $35, $51, $51, $19, $01, $00

     EINK200_LUT_TABLE      BYTE    $82, $00, $00, $00, $AA, $00, $00, $00      ' 90 bytes long!
                            BYTE    $AA, $AA, $00, $00, $AA, $AA, $AA, $00
                            BYTE    $55, $AA, $AA, $00, $55, $55, $55, $55
                            BYTE    $AA, $AA, $AA, $AA, $55, $55, $55, $55
                            BYTE    $AA, $AA, $AA, $AA, $15, $15, $15, $15
                            BYTE    $05, $05, $05, $05, $01, $01, $01, $01
                            BYTE    $00, $00, $00, $00, $00, $00, $00, $00
                            BYTE    $00, $00, $00, $00, $00, $00, $00, $00
                            BYTE    $00, $00, $00, $00, $00, $00, $00, $00
                            BYTE    $00, $00, $00, $00, $00, $00, $00, $00
                            BYTE    $41, $45, $F1, $FF, $5F, $55, $01, $00
                            BYTE    $00, $00

    EINK213_BIG_LUT_TABLE   BYTE    $A0, $90, $50, $00, $00, $00, $00           ' 70 bytes long!
                            BYTE    $50, $90, $A0, $00, $00, $00, $00
                            BYTE    $A0, $90, $50, $00, $00, $00, $00
                            BYTE    $50, $90, $A0, $00, $00, $00, $00
                            BYTE    $00, $00, $00, $00, $00, $00, $00
                            BYTE    $0F, $0F, $0F, $0F, $02, $10, $10
                            BYTE    $0A, $0A, $03, $08, $08, $09, $43
                            BYTE    $07, $00, $00, $00, $00, $00, $00
                            BYTE    $00, $00, $00, $00, $00, $00, $00
                            BYTE    $00, $00, $00, $00, $00, $00, $00

    EINK290_LUT_TABLE       BYTE    $A0, $90, $50, $00, $00, $00, $00           ' 70 bytes long!
                            BYTE    $50, $90, $A0, $00, $00, $00, $00
                            BYTE    $A0, $90, $50, $00, $00, $00, $00
                            BYTE    $50, $90, $A0, $00, $00, $00, $00
                            BYTE    $00, $00, $00, $00, $00, $00, $00
                            BYTE    $0F, $0F, $0F, $0F, $02, $10, $10
                            BYTE    $0A, $0A, $03, $08, $08, $09, $43
                            BYTE    $07, $00, $00, $00, $00, $00, $00
                            BYTE    $00, $00, $00, $00, $00, $00, $00
                            BYTE    $00, $00, $00, $00, $00, $00, $00

PRI frame_px(x, y, fntColor) | bitmapOffset, byteIdx
' place font pivToXl in device frame for later display
    byteIdx := (y * (DISPLAY_WIDTH / 8)) + (x / 4)
    bitmapOffset := (3 - (x +// 4)) * 2

    BYTE [@deviceFrame][byteIdx] &= !($03 << bitmapOffset)
    BYTE [@deviceFrame][byteIdx] |= ((fntColor & $03) << bitmapOffset)


PRI char_wr(chrCode) | descriptorOffset, chrWidth, fntIdxX, fntIdxY, frmX, frmY, dblX, dblY, rowBits, mask, bitmapOffset, pChrDescriptor, pChrBitmap
' place font character in device frame for later display

    ' exit if FONT doesn't have this character
    if(chrCode < first_char)
        return

    if(chrCode > last_char)
        return


    ' locate descriptor for this character
    descriptorOffset := (chrCode - first_char) << 2      ' NOTE: "<< 2" - descriptors are 4 bytes ea.
    pChrDescriptor := fontAddr + (8 + descriptorOffset) ' NOTE font header is 8 bytes

    ' load values from descriptor of this charactor
    chrWidth := BYTE [pChrDescriptor][0]
    bitmapOffset := BYTE [pChrDescriptor][1] + (BYTE [pChrDescriptor][2] << 8) + (BYTE [pChrDescriptor][3] << 16)

    ' addr of bits to write
    pChrBitmap := fontAddr + bitmapOffset

    ' now place bits in display buffer at specific location (deviceX, deviceY)
    if((fontOrientation == FO_HORIZONTAL) || (fontOrientation == FO_VERTICAL_COLUMN))
        ' place horizontal letter or horizontal letter (within vertical column)
        frmY := deviceY
        repeat fntIdxY from 0 to fontHeight - 1
            frmX := deviceX
            mask := 0
            repeat fntIdxX from 0 to chrWidth - 1
                if mask == 0
                    rowBits := BYTE [pChrBitmap]
                    pChrBitmap++
                    mask := $01

                if rowBits & mask
                    'frame_px(frmX, frmY, fontColor)
                    dblY := deviceY + fntIdxY * 2
                    frame_px(frmX, dblY, fontColor)
                    frame_px(frmX, dblY+1, fontColor)
                   'waitms(1)   ' PROXY for Delay_80us()

                frmX++
                mask <<= 1
                mask &= $ff

            frmY++

        if fontOrientation == FO_HORIZONTAL
            deviceX := frmX + 1    ' move to next char position HORIZONTAL
        else
            'deviceY := frmY        ' move to next char position VERTICAL
            deviceY := deviceY + (fontHeight * 2) - 1

    else
        ' place vertical letter
        frmY := deviceX
        repeat fntIdxY from 0 to fontHeight - 1
            frmX := deviceY
            mask := 0
            repeat fntIdxX from 0 to chrWidth - 1
                if mask == 0
                    rowBits := BYTE [pChrBitmap]
                    pChrBitmap++
                    mask := $01

                if rowBits & mask
                    'frame_px(frmY, frmX, fontColor)
                    dblX := deviceY - fntIdxX * 2
                    frame_px(frmY, dblX, fontColor)
                    frame_px(frmY, dblX+1, fontColor)
                    'waitms(1)   ' PROXY for Delay_80us()

                frmX--
                mask <<= 1
                mask &= $ff

            frmY++

        'deviceY := frmX - 1    ' move to next char position vertically
        deviceY := deviceY - (chrWidth * 2) - 1    ' move to next char position vertically

PRI writeCmd(data)
' write command byte(DC low = command)
    pinlow(pinbase + CLICK_OFST_DC)
    selectNWrite(data)


PRI writeData(data)
' write data byte(DC high = data)
    pinhigh(pinbase + CLICK_OFST_DC)
    selectNWrite(data)


PRI selectNWrite(dataByte) | count
' write byte to SPI
    ' select device
    pinlow(pinbase + CLICK_OFST_CS)
    ' clock out bits MSB first
    spi.shiftout(spi.MSBFIRST, dataByte, 8)
    ' deselect device
    pinhigh(pinbase + CLICK_OFST_CS)


CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright(c) 2022 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files(the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
